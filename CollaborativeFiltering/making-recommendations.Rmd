---
title: "Making Recommendations"
author: "Raimo Haikari"
date: "2022-12-02"
output: 
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Making Recommendations

## Esipuhe

Kauan aikaa sitten ostin Toby Segaranin kirjoittaman kirjan Programming Collective Intelligence.

Kirjassa esitellään kollektiivisen älykkyyden käyttökohteita ja -menetelmiä.

Aiheissa ei mennä kovin syvälle, vaan tarkoitus on antaa lukijalle yleiskuva. Mikäli kiinnostus herää, kirjan avulla on luotu pohja, jonka päälle tietämystä voi alkaa kerryttämään.

Kirjassa käydään läpi kymmenkunta sovellusaluetta, esimerkkeinä voidaan mainita luokittelu, optimointi, päätöspuut.

Joka alueesta rakennetaan malli Python kielellä 

Tämä opas pohjautuu suositteluja suosittelujärjestelmiä (Making Recommendations) koskevaan kappaleeseen.

Nyt ei kuitenkaan operoida Pythonilla, vaan olen toteuttanut toiminnallisuuden R-kielellä.

En ole muutamaan vuoteen ollut tekemissä R:n kanssa, joten koodini ei edusta tyylikkäintä saati tehokkainta tapaa kirjoittaa R:ää. Projekti on tarjonnut mukavan tavan palauttaa muistiin aiemmin opittua niin R:n kuin suosittelujärjestelmien kannalta.

Varoituksen sana! 

Työkirjassa toteutettavat funktiot ovat joiltain osin turhankin mutkikkaita. Työn edetessä olen pyrkinyt hyödyntämään aiemmin tuotettua koodia pienten muokkausten avulla. Tämä sinänsä on järkevää, mutta hankalaa koodin hahmottamisen kannalta, kun lukija saa nähtäväkseen lopullisen tuloksen - ja koodin muodostumisen välivaiheet jäävät pimentoon. 

Onneksi tämä on pieni opas, joten yleiskuvan muodostaminen pitäisi kuitenkin olla kohtuullisen saavutettavissa.

## Alkutoimet

Jotta pohjaa voisi käyttää eri aineistoilla, talletetaan laskennassa käytettävät sarakenimet muuttujiin. Tällöin (ainakin teoriassa) eri aineistoja pääsee pienellä vaivalla käyttämään
vaihtamalla muuttujien sisällöt vastaamaan käytettävää aineistoa.

Asetetaan muuttujien arvot.

```{r}
on_kaggle <- 0

# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
# Column that stores the grades
valueIdCol <- "Grade"
# Column that stores calculated similarity value
similarityCol <- "Similarity"


# Path of the directory where data is stored
if (on_kaggle == 0){
  path <- "./"
} else {
  path <- "../input/tmdb-movie-metadata/"
}
```

Ladataan tarvittavat paketit: 

```{r message=FALSE}
library(tidyverse)
```

Luetaan käytettävä aineisto:

```{r message=FALSE}
reviews <- read_csv(str_c(path, "recommendations.csv"), na="NA")
```

## Samankaltaisuutta mittaavat funktiot 

Käyttäjien mieltymysten samankaltaisuutta mitataan laskemalla heidän antamien arvosanojen välinen korrelaatio. 

Alkuperäinen opas esittää kaksi tapaa samankaltaisuuden laskemiseen:

- Euklidinen etäisyys
- Pearsonin korrelaatiokerroin.

Kirjoitetaan molempia menetelmiä varten omat funktionsa. 

Funktioita voi tarvittaessa määrittää helposti lisää. Riittää kun funktio ottaa parametrina kahden käyttäjän arvosanat ja palauttaa numeerisen vastauksen.

```{r}
# Calculate Euclidean Distance Score
# euclidean <- function(a,b) 1 / (1 + sqrt(sum((a-b)^2)))
euclidean <- function(a,b) 1 / (1 + sum((a-b)^2))

# Calculate Pearson Correlation Score
pearson <- function(a,b) cor(a, b, method = 'pearson')
```

## Kahden käyttäjän välinen samankaltaisuus

Käyttäjät ovat arvostelleet vaihtelevan määrän elokuvia. 

Korrelaatiota mittaavien funktioiden käyttö edellyttää, että erotetaan elokuvat, jotka molemmat ovat arvostelleet.

Tehdään funktio, joka:

- poimii elokuvat, jotka molemmat henkilöt ovat arvioineet
- palauttaa käyttäjien mieltymysten samankaltaisuutta mittaavan arvon.

```{r}

calculateSimilarityScore <- function(prefs, person1, person2, similarityFunction){

  # Extract items that persons have reviewed and make sure items are in the same order
  p1Reviews <- prefs[which(prefs[[personIdCol]] == person1),] %>% arrange(.[[itemIdCol]])
  p2Reviews <- prefs[which(prefs[[personIdCol]] == person2),] %>% arrange(.[[itemIdCol]])
  
  # Items that both have reviews
  sharedItems <- intersect(p1Reviews[,itemIdCol], p2Reviews[,itemIdCol]) %>%
      unlist(use.names = FALSE)
  
  if(length(sharedItems) == 0) 
    return(0)
  
  # Extract the grades of items both have graded
  p1Grades <- p1Reviews[which(p1Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
      unlist(use.names = FALSE)
  
  p2Grades <- p2Reviews[which(p2Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
      unlist(use.names = FALSE)
  
  return(similarityFunction(p1Grades, p2Grades))
  
}
```

Testataan toimiiko koodi, laskemalla kahden käyttäjän väliset korrelaatiot niin euklidisen kuin pearsonin menetelmä avulla:

```{r}
p1 = 'Lisa Rose'
p2 = 'Gene Seymour'

calculateSimilarityScore(reviews, p1, p2, euclidean)
calculateSimilarityScore(reviews, p1, p2, pearson)
```
## Ranking the Critics

Valitaan yksi arvostelija ja selvitetään hänen mieltymyksiään parhaiten vastaava ryhmä.

Tehdään tätä varten kaksi funktiota:

- getSimilarityScores vertaa suositusten saajaa muihin

```{r}

# calculate similarity scores using the selected similarity function
getSimilarityScores <- function(prefs, person, similarity) {
  
  # get the data.frame of other users
  others <- prefs[which(prefs[[personIdCol]] != person), personIdCol] %>% 
    distinct() 
  
  # calculate similarity scores
  similarity <- apply(
    others[,1], 
    1, 
    function(x) calculateSimilarityScore(prefs, person, x, similarity)
  )
  
  # add similarity scores to user data.frame
  others[similarityCol] = similarity
  
  # sort results
  others %>%
    arrange(desc(.[[similarityCol]]))

}
```

- topMatches poimii listalta kärkijoukon

Huom! Parametrin *includeOriginal* käyttötarkoitus selviää myöhemmin. 

```{r}
# Returns the best matches for person from the prefs table
topMatches <- function(prefs, person, n = 5, similarity = pearson, includeOriginal = FALSE) {
  
  # sort other users based on their similarity
  others <- getSimilarityScores(prefs, person , similarity)
  
  # pick top "n"
  others <- others %>% 
    top_n(n, wt = .[[similarityCol]])
  
  # in case needed store also the recommendee name 
  if(includeOriginal == TRUE) {
    others <- others %>% mutate(Target = person)
  }
  
  others
  
}
```

Haetaan **käyttäjälle Toby** kolme parasta osumaa.

```{r}
topMatches(reviews, 'Toby', n=3)
```

## Tuotteiden suosittelu

Suositusten antamiseen voisi valita muutaman parhaan osuman ja valikoida paremmuusjärjestyksessä sellaiset elokuvat, joita suositusten saaja ei ole vielä nähnyt.

Tällöin kuitenkin saattaa jäädä pimentoon elokuvia, jotka "kärkijoukolta" ovat jääneet näkemättä. Tai joku yksittäinen elokuva voi nousta liian korkeaan arvoon tilanteessa, jossa yksi on sattunut pitämään, mutta juuri kukaan muu ei.

Parempi vaihtoehto on käyttää aineistoa laajasti ja laskea elokuville ennusteet siitä kuinka suositusten saaja arvioisi ne.

Tämä saadaan aikaan, kun:

- selvitetään elokuvat, joita suositusten saaja ei ole vielä nähnyt
- muiden käyttäjien näille elokuville antamat arviot huomioidaan samankaltaisuutta mittaavan arvon suhteessa.

Kuinka edellinen toteutetaan on helpointa hahmottaa oheisen kuvan avulla.

![Creating recommendations for Toby](https://raw.githubusercontent.com/RaimoHaikari/tahtisadetta/main/Misc/creatingRecommendationsForToby-opti.svg)

Esimerkissä annetaan Toby:lle suosituksia. 

Hän ei ole vielä nähnyt kolmea elokuvaa:

- The Night Listener
- Lady in the Water
- Just My Luck

Tiedossa on kuinka muut käyttäjät ovat kyseiset elokuvat arvioineen ja kuinka hyvin muiden heidön makumieltymykset vastaavat Tobyn kanssa.

Laskenta etenee siten, että:

1. elokuva kerrallaan muiden antamat arvosanat kerrotaan heidän painoarvollaan
2. lasketaan kunkin elokuvan arvioiden summa
3. lasketaan yhteen myös kunkin elokuvan laskuissa mukana olleet painoarvot
4. jaetaan arvosanojen summa painokertoimien summalla.

Esim. Rose oli arvioinut The Night Listener elokuvan kolmosen arvoiseksi. Rosen ja Tobyn *Similarity-arvo* on 0.99, joten Roselta kertyy elokuvalle 2.97 pistettä. Yhteensä elokuva sai 12.89 pistettä. Kun elokuvan nähneiden käyttäjien painoarvot lasketaan yhteen, saadaan Sim.Sum arvoksi 3.84. Kun arvosanojen summa jaetaan painojen summalla, saadaan tulokseksi 3.35.

Kun saatiin tämä alta. Voidaankin jo siirtyä toimenpiteen suorittavan funktion pariin:

```{r}

getRecommendations <- function(prefs, person, similarity) {
  
  # extract the items recommendee has already reviewed
  personsReviews <- prefs[which(prefs[[personIdCol]] == person), itemIdCol] %>% 
    unlist(use.names = FALSE)
  
  # get recommenders similarity socres
  others <- getSimilarityScores(prefs, person , similarity)

  # add reviews to the similarity table
  others <- others %>% left_join(prefs, by=personIdCol) 
  
  # remove items recommendee has already reviewed and ignore scores of zero or lower
  conditionA <- !others[[itemIdCol]] %in% personsReviews
  conditionB <- others$Similarity > 0

  others <- others[which(conditionA & conditionB),]
  
  # calculate similarity * grade
  others$simXGrade <- others[[valueIdCol]] * others$Similarity

  # for each movie calculate sums of Similarity and similatiry * grade
  # then ESTIMATED GRADE IS CALCULTED BY DIVISION..
  others %>% 
    group_by_at(itemIdCol) %>%
    summarise(Total = sum(simXGrade), Sim.Sum = sum(Similarity)) %>%
    mutate(Estimate = Total / Sim.Sum, .keep = "unused") %>%
    arrange(desc(.[[itemIdCol]]))

}

```

Nyt voidaan kokeilla mitä algoritmit suosittelevat Toby:lle:

```{r}
getRecommendations(reviews, 'Toby', euclidean)
```

## Tuotteiden vastaavuuden arvioiminen

Tähän saakka olemme etsineet samanlaisia käyttäjiä. Mutta yhtä lailla voidaan tutkia elokuvien välistä samankaltaisuutta.

Eikä tämä ole edes vaikeaa, kun kaukaa viisaina olemme tallentaneet käyttämämme sarakenimet muuttujiin.

Riittää kun vaihdamme henkilöihin ja tuotteisiin viitanneiden muuttujien arvot keskenään.

```{r}
# Column that is used to identify persons
personIdCol <- "Movie"
# Column that is used to identify items
itemIdCol <- "Person"
```

Nyt voimme tutkia mitkä elokuva aineiston mukaan muistuttavat esim. elokuvaa *Superman Returns*.

```{r}
#topMatches(reviews, 'Superman Returns',5, euclidean)
topMatches(reviews, 'Superman Returns',5, pearson)
```

## Tuoteperusteinen suodatus

Aineiston kasvaessa on tapana käyttää menetelmää, jossa aineiston sisältämät samankaltaisuudet lasketaan valmiiksi etukäteen.

Kun myöhemmin halutaan antaa suosituksia:

- katsotaan mistä elokuvista suositusten saaja oli pitänyt 
- haetaan esikäsitellystä materiaalista näiden elokuvien kanssa vuorovaikutuksessa olleet elokuvat
- lasketaan elokuvien keskinäisten painokertoimien avulla uusille elokuville ennustetut arvosanat
- palautetaan parhaan odotusarvon saaneet elokuvat.

Menetelmä nopeuttaa laskentaa, kun suurin iso osa työstä on tehty jo etukäteen.

Tuotteiden keskinäiset suhteet muuttuvat hitaasti, jos ollenkaan. Näin ollen samankaltaisuuksien uudelleen laskennat voidaan suorittaa isompia kokonaisuuksina sopivaksi katsotun aikataulun puitteissa.


### Tuotetaulukon laskenta

On taas aika kääriä hihat ja toteuttaa funktio, joka laskee elokuvien väliset samankaltaisuudet.

Huom! Koska ollaan laskemassa elokuvien välisiä korrelaatioita, intuition vastaisesti muuttujan personIdCol sisältö viittaa suoritushetkellä sarakkeeseen, johon on talletettu tuotteiden nimet. Lähemmin tarkasteltuna, emme muuttujia nimetessämme olleet aivan niin viisaita kuin luulimme.

Toinen huomioinarvoinen seikka on, että nyt haluamme tallettaa myös suositusten saajan nimen topMatches -funktion palauttamaan data.frameen!

```{r}
calculateSimilarItems <- function(prefs, n = 10, similarity = pearson) {
  
  # Get the list of movies!
  items <- unique(prefs[[personIdCol]])
  
  # For each item, calculate similarity values with other items
  # - Now we also wan't to include name of the target in topMatches
  itemSimList <-  apply(
    as.data.frame(items), 
    1, 
    function(x) topMatches(
      prefs, 
      x[1],
      similarity = euclidean, 
      includeOriginal = TRUE
    )
  )

  # Previous phase results list of data.frames
  # convert that data structure to single Data.Frame
  do.call("rbind", itemSimList)

}
```

Kuten aiemmin jo todettiin, laskettaessa elokuvien välisiä *Similarity-arvoja*:

- personIdCol muuttujan pitää viitata sarakkeeseen johon on tallennettu elokuvien nimet
- itemIdCol muuttujan pitää viitata sarakkeeseen, johon on tallennettu henkilöiden nimet.

Kun tämä ehto toteutuu, voidaan laskea elokuvien välinen vertailutaulukko.

```{r}
# Column that is used to identify persons
personIdCol <- "Movie"
# Column that is used to identify items
itemIdCol <- "Person"


itemsim <- calculateSimilarItems(reviews)
```

### Suositusten laskeminen

Kun elokuvien keskinäinen samankaltaisuus on määritetty, voidaan tietoa hyödyntää käyttäjille tarjottavissa suosituksissa.

Käytetään jälleen apuna Tobyn kirjassaan esittämää mallitapausta.

Toby on arvioinut elokuvat:

- Snakes on a Plane
- Superman Returns
- You, Me and Dupree

Sen sijaan hän ei ole vielä nähnyt elokuvia: The Night Listener, Lady in the Water ja Just My Luck.

Kun elokuvien keskinäisiä samankaltaisuuksia on arvioitu, niin Snakes on Plane sai edellä lueteltujen elokuvien kanssa seuraavat arvot:

- The Night Listener 0.182
- Lady in the Water 0.222
- Just My Luck 0.105

Kunkin elokuvan ennuste saadaan kertomalla Tobyn näkemillensä elokuville antamat arvosanat elokuvien samanlaisuutta mittaavalla arvolla.  

Nämä lasketaan yhteen ja tulos jaetaan samankaltaisuutta mitanneiden arvojen summalla.

Elokuvan The Night Listener tapauksessa laskutoimitukset ovat:

1. 4.5 * 0.182 + 4.0 * 0.103 + 1.0 * 0.148 = 1.378
2. 0.182 + 0.103 + 0.148 = 0.433
3. 1.378 / 0.433 = 3.183


![Tuoteperusteinen suosittelu](https://raw.githubusercontent.com/RaimoHaikari/tahtisadetta/main/Misc/itemBasedRecommendationsForToby-opti.svg)

Viimeisenä esiteltävä funktio getRecommendedItems suorittaa em. toimenpiteet.

```{r}

getRecommendedItems <- function(prefs, itemMatch, user) {
  
  # Extract the movies user has seen, keep movie and grade
  userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
  # get vector of movie names
  moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
  
  
  # From the similarity data.frame select movies that:
  # - user has reviewed
  # - with each of those records, keep the ones where "the movie in compare" 
  #   is new to user...
  conditionA <- itemMatch[[itemIdCol]] %in% moviesUserHasRated
  conditionB <- !itemMatch$Target %in% moviesUserHasRated
  
  scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
  
  # combine user ratings with similarity data
  userRatings <- userRatings %>% left_join(scores, by = "Movie") 

  # multiply ratings with similarity values
  userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
  
  # calculate sums of similarity multiplied grades and similarities
  # calculate final by normalizing sums of multiplied grades
  userRatings %>%
    group_by(Target) %>%
    summarise(Estimate = sum(Score) / sum(Similarity)) %>%
    arrange(desc(Estimate))

}
```

Palautetaan sarakeasetukset tilaan, jossa:

- personIdCol viittaa henkilötiedot sisältävään sarakkeeseen
- itemIdCol viittaa arvosteltavat objektit sisältävään sarakkeeseen

Haetaan valmiiksi lasketun aineiston avulla suositukset Toby:lle

```{r}
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"

getRecommendedItems(reviews, itemsim, 'Toby')
```

### Loppusanat

Mukavaa kun jaksoit loppuun asti. Toivottavasti oppaasta on sinulle hyötyä.

Kuten jo alussa totesin, opas esittelee yksinkertaisen menetelmän suositusten laskemiseen.

Suositusten antamiseen liittyy monenlaisia haasteita. Eräs näistä on aineiston hajanaisuus. Elokuvien tapauksessa tämä tarkoittaa sitä, että:

- elokuvia on paljon
- näistä sellaisia, joita monet ovat arvioineen, on vain vähän.

Tähän ja muihin haasteisiin pyritään vastaamaan kehittämällä entistä hienostuneempia suosittelujärjestelmiä.

Aihe kiinnostaa, sillä kuluttajakäyttäytymisen tarkemman ennustamisen avulla voidaan kehittää asiakaskokemusta ja sitä myöten kasvattaa tuottoja.
