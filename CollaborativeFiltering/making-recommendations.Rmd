---
title: "Making Recommendations"
author: "Raimo Haikari"
date: "2022-12-02"
output: 
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Making Recommendations

## Preface

Kauan aikaa sitten ostin Toby Segaranin kirjoittaman kirjan Programming Collective Intelligence.

Kirjassa esittellään kollektiivisen älykkyyden käyttökohteita ja -menetelmiä.

Aiheissa ei mennä kovin syvälle, vaan tarkoitus on antaa lukijalle yleiskuva, jonka avulla aihealueisiin voi syvällisemmin paneutua - mikäli kiinnostusta riittää.

Kirjassa käydään läpi kymmenkunta sovellusaluetta, esimerkkeinä voidaan mainita luokkittelu, optimointi, päätöspuut.

Joka alueesta rakennetaan malli python kielellä 

Tämä opas pohjautuu suositteluja (Making Recommendations) koskevaan kappaleeseen.

Nyt ei kuitenkaan operoidan pythonilla, vaan parhaani mukaan olen toteuttanut toiminnallisuuden R-kielellä.

Muutamaan vuoteen en ole ollut tekemissä R:n kanssa, joten koodini ei edusta tyylikkäintä saati tehokkainta tapaa kirjoittaa R:ää. Juurikin tästä syystä, tämä projekti on tarjonnut mukavan tavan virkistää muistia niin R:n kuin suosittelujärjestelmien kannalta.

Varoituksen sana! 

Koodit ovat joiltain osin turhankin mutkikkaita, koska työn edetessä olen pyrkinyt hyödyntämään 
aiemmin tuotettua koodia pienten muokkausten avulla. Tämä sinänsä on järkevää, mutta hankalaa hahmottamisen kannalta, kun lukija saa nähtäväkseen lopullisen tuloksen - ja koodin muodostumisen evoluutio jää pimentoon. 

Onneksi tämä on aika pieni opas, joten yleiskuvan muodostaminen pitäisi kuitenkin olla kohtuullisen saavutettavissa.

*Maininta siitä, että tässä oppaassa käsitellään elokuvia, joten käytettävät termit heijastelevat aihealuetta. Mutta samat periaatteet ovat yleistettävissä muihinkin kohteisiin.*

## Setup Environment

Jotta pohjaa voisi käyttää eri aineistoilla, talletetaan laskennassa käytettävät sarakenimet muuttujiin. Tällöin (ainakin teoriassa) eri aineistoja pääsee pienellä vaivalla käyttämään
vaihtamalla muuttujien sisällöt vastaamaan käytettävää aineistoa.

Recommendee is the target of recommendations.

Asetetaan muuttujien arvot.

```{r}
on_kaggle <- 0

# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
# Column that stores the grades
valueIdCol <- "Grade"
# Column that stores calculated similarity value
similarityCol <- "Similarity"


# Path of the directory where data is stored
if (on_kaggle == 0){
  path <- "./"
} else {
  path <- "../input/tmdb-movie-metadata/"
}
```

Ladataan tarvittavat paketit: 

```{r message=FALSE}
library(tidyverse)
```

Luetaan käytettävä aineisto:

```{r message=FALSE}
reviews <- read_csv(str_c(path, "recommendations.csv"), na="NA")
```

## Score Functions 

The original tutorial shows two alternatives to calculate a similarity score between to users.

- Euclidean distance score
- Pearson correlation score

Funktioita voi määrittää tarvittaessa lisää. Riittää kun funktio ottaa parametrinä kahden käyttäjän arvosanat ja palauttaa numeerisen vastauksen.

```{r}
# Calculate Euclidean Distance Score
# euclidean <- function(a,b) 1 / (1 + sqrt(sum((a-b)^2)))
euclidean <- function(a,b) 1 / (1 + sum((a-b)^2))

# Calculate Pearson Correlation Score
pearson <- function(a,b) cor(a, b, method = 'pearson')
```

## Kahden käyttäjän välinen samankaltaisuus

Käyttäjät ovat arvostelleet vaihtelevan määrän elokuvia. 

Korrelaatiota mittaavien funktioiden käyttö edellyttää, että erotetaan elokuvat, jotka molemmat ovat arvostelleet.

Tehdään funktio, joka:

- poimii kohteen, jotka molemmat henkilöt ovat arvioineet
- palauttaa käyttäjien mieltymysten korrelaatiota mittaavan arvon


```{r}

calculateSimilarityScore <- function(prefs, person1, person2, similarityFunction){

  # Extract items that persons have reviewed and make sure items are in the same order
  p1Reviews <- prefs[which(prefs[[personIdCol]] == person1),] %>% arrange(.[[itemIdCol]])
  p2Reviews <- prefs[which(prefs[[personIdCol]] == person2),] %>% arrange(.[[itemIdCol]])
  
  # Items that both have reviews
  sharedItems <- intersect(p1Reviews[,itemIdCol], p2Reviews[,itemIdCol]) %>%
      unlist(use.names = FALSE)
  
  if(length(sharedItems) == 0) 
    return(0)
  
  # Extract the grades of items both have graded
  p1Grades <- p1Reviews[which(p1Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
      unlist(use.names = FALSE)
  
  p2Grades <- p2Reviews[which(p2Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
      unlist(use.names = FALSE)
  
  return(similarityFunction(p1Grades, p2Grades))
  
}
```

Testataan toimiiko koodi laskemalla kahden käyttäjän väliset korrelaatiot niin euklidisen kuin pearsonin korrelaatiofunktion avulla:

```{r}
p1 = 'Lisa Rose'
p2 = 'Gene Seymour'

calculateSimilarityScore(reviews, p1, p2, euclidean)
calculateSimilarityScore(reviews, p1, p2, pearson)
```
## Ranking the Critics

Valitaan yksi arvostelija ja selvitetään materiaalin avulla parhaiten hänen mieltymyksiää edustava joukko.

Tehdään tätä varten kaksi funktiota:

- getSimilarityScores vertaa suositusten saajaa kaikkiin muihin aineiston **käyttäjiin**

```{r}

# calculate similarity scores using the selected similarity function
getSimilarityScores <- function(prefs, person, similarity) {
  
  # get the data.frame of other users
  others <- prefs[which(prefs[[personIdCol]] != person), personIdCol] %>% 
    distinct() 
  
  # calculate similarity scores
  similarity <- apply(
    others[,1], 
    1, 
    function(x) calculateSimilarityScore(prefs, person, x, similarity)
  )
  
  # add similarity scores to user data.frame
  others[similarityCol] = similarity
  
  # sort results
  others %>%
    arrange(desc(.[[similarityCol]]))

}
```

- topMatches poimii listalta kärkijoukon

Huom! Parametrin *includeOriginal* käyttötarkoitus selviää myöhemmin. 

```{r}
# Returns the best matches for person from the prefs table
topMatches <- function(prefs, person, n = 5, similarity = pearson, includeOriginal = FALSE) {
  
  # sort other users based on their similarity
  others <- getSimilarityScores(prefs, person , similarity)
  
  # pick top "n"
  others <- others %>% 
    top_n(n, wt = .[[similarityCol]])
  
  # in case needed store also the recommendee name 
  if(includeOriginal == TRUE) {
    others <- others %>% mutate(Target = person)
  }
  
  others
  
}
```

Haetaan **käyttäjälle** **Toby** kolme parasta osumaa.

```{r}
topMatches(reviews, 'Toby', n=3)
```

## Recommending Items

Suositusten antamiseen voisi tietenkin valita muutaman parhaan osuman ja valita *paremmuusjärjestyksessä* listalta sellaiset elokuvat, joita suositusten saaja ei ole viellä nähnyt.

Tällöin kuitenkin saattaa jäädä pimentoon sellaisia, elokuvia jotka juuri tältä *kärkijoukolta* ovat jääneet näkemättä. Ja toisaalta joku yksittäinen elokuva voi nousta liian korkeaan arvoon, tilanteessa jossa yksi on sattunut pitämään, mutta juuri kukaan muu ei.

Parempi vaihtoehto on käyttää aineistoa laajasti ja laskea elokuville painotetut ennusteet siitä kuinka suositusten saaja arvioisi ne.

Huomioidaan kaikki elokuvaan kohdistuneet arvostelut arvostelijan *similarity-arvon* mukaisella painotuksena. 

Käytetään apuna Toby Segaranin kirjassa käyttämää esimerkkiä.

Aineistossa on laskettu kuudelle käyttäjälle *similarity-arvot*. Näiden perusteella lasketaan arviot kolmelle elokuvalle:

- The Night Listener
- Lady in the Water
- Just My Luck

Laskenta etenee siten, että:

1. Kunkin arvostelijan antama arvosana kerrotaan arvostelijan *Similarity-arvolla*
2. Lasketaan yhteen kunkin elokuvan *Similarity-arvolla* kerrotut arvosanat
3. Lasketaan yhteen kunkin elokuvan laskuissa mukana olleet *Similarity-arvot*
4. Jaetaan arvosanojen summa painokertoiminen summalla.

Esim. Rose oli arvioinut The Night Listener elokuvan kolmosen arvoiseksi. Rosen ja Tobyn *Similarity-arvo* on 0.99, joten Roselta kertyy elokuvalle 2.97 pistettä. Yhteensä elokuva sai 12.89 pistettä. Kun kaikkien osallistunteiden kriitikkojen *Similarity-arvot* lasketaan yhteen, saadaan Sim.Sum arvoksi 3.84. Ja kun arvosanojen summa jaetaan painojen summalla, saadaan tulokseksi 3.35



![Creating recommendations for Toby](https://raw.githubusercontent.com/RaimoHaikari/tahtisadetta/main/Misc/creatingRecommendationsForToby-opti.svg)

Kun saatiin tämä alta. Voidaan keskittyä toimenpiteen suorittavan funktion kirjoittamiseen.

```{r}

getRecommendations <- function(prefs, person, similarity) {
  
  # extract the items recommendee has already reviewed
  personsReviews <- prefs[which(prefs[[personIdCol]] == person), itemIdCol] %>% 
    unlist(use.names = FALSE)
  
  # get recommenders similarity socres
  others <- getSimilarityScores(prefs, person , similarity)

  # add reviews to the similarity table
  others <- others %>% left_join(prefs, by=personIdCol) 
  
  # remove items recommendee has already reviewed and ignore scores of zero or lower
  conditionA <- !others[[itemIdCol]] %in% personsReviews
  conditionB <- others$Similarity > 0

  others <- others[which(conditionA & conditionB),]
  
  # calculate similarity * grade
  others$simXGrade <- others[[valueIdCol]] * others$Similarity

  # for each movie calculate sums of Similarity and similatiry * grade
  # then ESTIMATED GRADE IS CALCULTED BY DIVISION..
  others %>% 
    group_by_at(itemIdCol) %>%
    summarise(Total = sum(simXGrade), Sim.Sum = sum(Similarity)) %>%
    mutate(Estimate = Total / Sim.Sum, .keep = "unused") %>%
    arrange(desc(.[[itemIdCol]]))

}

```

Nyt voidaan kokeilla mitä algoritmit suosittelevat käyttäjälle:

```{r}
getRecommendations(reviews, 'Toby', euclidean)
```

## Matching Products

Tähän saakka olemme etsineet samalaisia käyttäjiä. 

Mutta yhtä lailla voidaan tutkia elokuvien välistä samankaltaisuutta.

Eikä tämä ole edes vaikeaa, kun kaukaa viisaina olemme tallettaneet käyttämämme sarakenimet muuttujiin.

Riittää kun vaihdamme henkilöihin ja tuotteisiin viitanneiden muuttujien arvot keskenään.

```{r}
# Column that is used to identify persons
personIdCol <- "Movie"
# Column that is used to identify items
itemIdCol <- "Person"
```

Nyt voimme tutkia mitkä elokuva aineiston mukaan muistuttavat esim. elokuvaa *Superman Returns*.

```{r}
#topMatches(reviews, 'Superman Returns',5, euclidean)
topMatches(reviews, 'Superman Returns',5, pearson)
```

## Item-Based Filtering

Aineiston kasvaessa on tapana käyttää menetelmää, jossa lasketaan käytettävissä olevan materiaalin avulla valmiiksi tuotteiden väliset samankaltaisuus arviot.

Kun sitten käyttäjälle halutaan antaa suosituksia:

- katsotaan mistä hän oli pitänyt
- selvitetään valmiiksi lasketun aineiston perusteella mitkä elokuvat puolestaan muistuttavat näitä
- lasketaan näiden elokuvien *painotetut arviot*

### Building the Item Comparison set

Kirjoitetaan funktio, joka laskee elokuvien väliset *Similarity arvot*.

Huom! Koska ollaan laskemassa elokuvien välisiä korrelaatioita, muuttujan intuition vastaisesti personIdCol sisältö viittaa suoritushetkellä sarakkeeseen, johon on talletettu tuotteiden nimet. Lähemmin tarkasteltuna, emme siis olleetkaan aivan niin viisaita kuin luulimme olevamme muuttujia nimetessämme.

Toinen huomioinarvoinen seikka on, että nyt haluamme tallettaa myös suositusten saajan nimen topMatches -funktion palauttamaan data.frameen!

```{r}
calculateSimilarItems <- function(prefs, n = 10, similarity = pearson) {
  
  # Get the list of movies!
  items <- unique(prefs[[personIdCol]])
  
  # For each item, calculate similarity values with other items
  # - Now we also wan't to include name of the target in topMatches
  itemSimList <-  apply(
    as.data.frame(items), 
    1, 
    function(x) topMatches(prefs, x[1],similarity = euclidean, 
    includeOriginal = TRUE)
  )

  # Previous phase results list of data.frames
  # convert that data srructure to single Data.Frame
  do.call("rbind", itemSimList)

}
```

Kuten aiemmin jo todettiin, laskettaessa elokuvien välisiä *Similarity-arvoja*:

- personIdCol muuttujan pitää viitata sarakkeeseen johon on tallennettu elokuvien nimet
- itemIdCol muuttujan pitää viitata sarakkeeseen, johon on tallennettu henkilöiden nimet.

Kun tämä ehto toteutuu, voidaan laskea elokuvien välinen vertailutaulukko.

```{r}
# Column that is used to identify persons
personIdCol <- "Movie"
# Column that is used to identify items
itemIdCol <- "Person"


itemsim <- calculateSimilarItems(reviews)
```

### Getting Recommendations

Kun objektien keskinäinen samankaltaisuus on määritetty, voidaan sitä käyttää yksittäiselle käyttäjälle tarjotuissa suosituksissa.

Viimeisenä funktiona


```{r}

getRecommendedItems <- function(prefs, itemMatch, user) {
  
  # Extract the movies user has seen, keep movie and grade
  userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
  # get vector of movie names
  moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
  
  
  # From the similarity data.frame select movies that:
  # - user has reviewed
  # - with each of those records, keep the ones where "the movie in compare" 
  #   is new to user...
  conditionA <- itemMatch[[itemIdCol]] %in% moviesUserHasRated
  conditionB <- !itemMatch$Target %in% moviesUserHasRated
  
  scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
  
  # combine user ratings with similarity data
  userRatings <- userRatings %>% left_join(scores, by = "Movie") 

  userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
  
  userRatings %>%
    group_by(Target) %>%
    summarise(Estimate = sum(Score) / sum(Similarity)) %>%
    arrange(desc(Estimate))
}
```

Palautetaan sarakeasetukset tilaan, jossa:

- personIdCol viittaa henkilötiedot sisältävään sarakkeeseen
- itemIdCol viittaa arvosteltavat objektit sisältävään sarakkeeseen

Ja haetaan valmiiksi lasketun, elokuvien samankaltaisuutta arvioivan aineiston avulla suositukset käyttäjälle *Toby*

```{r}
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"

fooBar <- getRecommendedItems(reviews, itemsim, 'Toby')
```


