conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>%
left_join(scores, by = "Movie") %>%
mutate(Prod = Grade * Similarity)
print(userRatings)
}
getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[valueIdCol] * userRatings$Similarity
print(userRatings)
}
getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
print(userRatings)
}
getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
userRatings
}
foo <- getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
userRatings %>%
group_by_at(itemIdCol) %>%
summarise(Total = sum(Score), Sim.Sum = sum(Similarity))
userRatings
}
foo <- getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
userRatings <- userRatings %>%
group_by(Original) %>%
summarise(Total = sum(Score), Sim.Sum = sum(Similarity))
userRatings
}
foo <- getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
userRatings <- userRatings %>%
group_by(Original) %>%
summarise(Total = sum(Score), Sim.Sum = sum(Similarity) , Estimate = sum(Score) / sum(Similarity))
userRatings
}
foo <- getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
userRatings %>%
group_by(Original) %>%
summarise(Estimate = sum(Score) / sum(Similarity))
}
foo <- getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
userRatings %>%
group_by(Original) %>%
summarise(Estimate = sum(Score) / sum(Similarity)) %>%
arrange(desc(Estimate))
}
foo <- getRecommendedItems(reviews, itemsim, 'Toby')
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
getRecommendedItems <- function(prefs, itemMatch, user) {
userRatings <- prefs[which(prefs[[personIdCol]] == user), c(itemIdCol, valueIdCol)]
moviesUserHasRated <- userRatings[[itemIdCol]] %>% unlist(use.names = FALSE)
# From the similarity matrix select movies:
# - user have reviewed
# - with each of those similarity no new ones
conditionA <- itemMatch$Movie %in% moviesUserHasRated
conditionB <- !itemMatch$Original %in% moviesUserHasRated
scores <- itemMatch[which(conditionA & conditionB),] %>% arrange(.[[itemIdCol]])
userRatings <- userRatings %>% left_join(scores, by = "Movie")
userRatings$Score <- userRatings[[valueIdCol]] * userRatings$Similarity
userRatings %>%
group_by(Original) %>%
summarise(Estimate = sum(Score) / sum(Similarity)) %>%
arrange(desc(Estimate))
}
print(getRecommendedItems(reviews, itemsim, 'Toby'))
knitr::opts_chunk$set(echo = TRUE)
on_kaggle <- 0
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
# Column that stores the grades
valueIdCol <- "Grade"
if (on_kaggle == 0){
path <- "./"
} else {
path <- "../input/tmdb-movie-metadata/"
}
library(tidyverse)
reviews <- read_csv(str_c(path, "recommendations.csv"), na="NA")
p1 = 'Lisa Rose'
p2 = 'Gene Seymour'
print(calculateSimilarityScore(reviews, p1, p2, euclidean))
# Calculate Euclidean Distance Score
euclidean <- function(a,b) 1 / (1 + sqrt(sum((a-b)^2)))
# euclidean <- function(a,b) 1 / (1 + sum((a-b)^2))
# Calculate Pearson Correlation Score
pearson <- function(a,b) cor(a, b, method = 'pearson')
calculateSimilarityScore <- function(prefs, person1, person2, similarityFunction){
# Extract items that persons have reviewed and make sure items are in the same order
p1Reviews <- prefs[which(prefs[[personIdCol]] == person1),] %>% arrange(.[[itemIdCol]])
p2Reviews <- prefs[which(prefs[[personIdCol]] == person2),] %>% arrange(.[[itemIdCol]])
# Items that both have reviews
sharedItems <- intersect(p1Reviews[,itemIdCol], p2Reviews[,itemIdCol]) %>%
unlist(use.names = FALSE)
if(length(sharedItems) == 0)
return(0)
# Extract the grades of items both have graded
p1Grades <- p1Reviews[which(p1Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
unlist(use.names = FALSE)
p2Grades <- p2Reviews[which(p2Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
unlist(use.names = FALSE)
return(similarityFunction(p1Grades, p2Grades))
}
# calculate similarity scores using the selected similarity function
getSimilarityScores <- function(prefs, person, similarity) {
others <- prefs[which(prefs[[personIdCol]] != person), personIdCol] %>%
distinct()
similarity <- apply(others[,1], 1, function(x) calculateSimilarityScore(prefs, person, x, similarity))
others %>%
mutate(Similarity = similarity) %>%
arrange(desc(Similarity))
}
# Returns the best matches for person from the prefs dctionary
topMatches <- function(prefs, person, n = 5, similarity = pearson, includeOriginal = FALSE) {
others <- getSimilarityScores(prefs, person , similarity)
others %>%
top_n(n, wt = Similarity)
if(includeOriginal == TRUE) {
others <- others %>% mutate(Original = person)
}
others
}
getRecommendations <- function(prefs, person, similarity) {
# extract the items recommendee has already reviewed
personsReviews <- prefs[which(prefs[[personIdCol]] == person), itemIdCol] %>% unlist(use.names = FALSE)
# get recommenders similarity socres
others <- getSimilarityScores(prefs, person , similarity)
# add reviews to the similarity table
others <- others %>% left_join(prefs, by=personIdCol)
# remove items recommendee has already reviewed and ignore scores of zero or lower
conditionA <- !others[[itemIdCol]] %in% personsReviews
conditionB <- others$Similarity > 0
others <- others[which(conditionA & conditionB),]
# calculate similarity * grade
others$simXGrade <- others[[valueIdCol]] * others$Similarity
# for each movie calculate sums of Similarity and similatiry * grade
# then ESTIMATED GRADE IS CALCULTED BY DIVISION..
others %>%
group_by_at(itemIdCol) %>%
summarise(Total = sum(simXGrade), Sim.Sum = sum(Similarity)) %>%
mutate(Estimate = Total / Sim.Sum, .keep = "unused") %>%
arrange(desc(.[[itemIdCol]]))
}
calculateSimilarItems <- function(prefs, n = 10) {
items <- unique(prefs[[personIdCol]])
itemSimList <-  apply(
as.data.frame(items),
1,
function(x) topMatches(prefs, x[1],similarity = euclidean, includeOriginal = TRUE)
)
do.call("rbind", itemSimList)
}
p1 = 'Lisa Rose'
p2 = 'Gene Seymour'
print(calculateSimilarityScore(reviews, p1, p2, euclidean))
print(calculateSimilarityScore(reviews, p1, p2, pearson))
topMatches(reviews, 'Toby')
topMatches_ <- function(prefs, person, n = 5, similarity = pearson, includeOriginal = FALSE) {
others <- getSimilarityScores(prefs, person , similarity)
others %>%
top_n(n, wt = Similarity)
if(includeOriginal == TRUE) {
others <- others %>% mutate(Original = person)
}
others
}
topMatches_(reviews, 'Toby')
View(reviews)
topMatches(reviews, 'Toby')
on_kaggle <- 0
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
# Column that stores the grades
valueIdCol <- "Grade"
# Column that stores calculated similarity value
similarityCol <- "Similarity"
if (on_kaggle == 0){
path <- "./"
} else {
path <- "../input/tmdb-movie-metadata/"
}
# Calculate Euclidean Distance Score
euclidean <- function(a,b) 1 / (1 + sqrt(sum((a-b)^2)))
# euclidean <- function(a,b) 1 / (1 + sum((a-b)^2))
# Calculate Pearson Correlation Score
pearson <- function(a,b) cor(a, b, method = 'pearson')
calculateSimilarityScore <- function(prefs, person1, person2, similarityFunction){
# Extract items that persons have reviewed and make sure items are in the same order
p1Reviews <- prefs[which(prefs[[personIdCol]] == person1),] %>% arrange(.[[itemIdCol]])
p2Reviews <- prefs[which(prefs[[personIdCol]] == person2),] %>% arrange(.[[itemIdCol]])
# Items that both have reviews
sharedItems <- intersect(p1Reviews[,itemIdCol], p2Reviews[,itemIdCol]) %>%
unlist(use.names = FALSE)
if(length(sharedItems) == 0)
return(0)
# Extract the grades of items both have graded
p1Grades <- p1Reviews[which(p1Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
unlist(use.names = FALSE)
p2Grades <- p2Reviews[which(p2Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
unlist(use.names = FALSE)
return(similarityFunction(p1Grades, p2Grades))
}
# calculate similarity scores using the selected similarity function
getSimilarityScores <- function(prefs, person, similarity) {
others <- prefs[which(prefs[[personIdCol]] != person), personIdCol] %>%
distinct()
similarity <- apply(
others[,1],
1,
function(x) calculateSimilarityScore(prefs, person, x, similarity)
)
#others %>%
#  mutate(Similarity = similarity) %>%
#  arrange(desc(Similarity))
others[similarityCol] = similarity
others %>%
arrange(desc(Similarity))
}
# Returns the best matches for person from the prefs dctionary
topMatches <- function(prefs, person, n = 5, similarity = pearson, includeOriginal = FALSE) {
others <- getSimilarityScores(prefs, person , similarity)
others %>%
top_n(n, wt = Similarity)
if(includeOriginal == TRUE) {
others <- others %>% mutate(Original = person)
}
others
}
getRecommendations <- function(prefs, person, similarity) {
# extract the items recommendee has already reviewed
personsReviews <- prefs[which(prefs[[personIdCol]] == person), itemIdCol] %>% unlist(use.names = FALSE)
# get recommenders similarity socres
others <- getSimilarityScores(prefs, person , similarity)
# add reviews to the similarity table
others <- others %>% left_join(prefs, by=personIdCol)
# remove items recommendee has already reviewed and ignore scores of zero or lower
conditionA <- !others[[itemIdCol]] %in% personsReviews
conditionB <- others$Similarity > 0
others <- others[which(conditionA & conditionB),]
# calculate similarity * grade
others$simXGrade <- others[[valueIdCol]] * others$Similarity
# for each movie calculate sums of Similarity and similatiry * grade
# then ESTIMATED GRADE IS CALCULTED BY DIVISION..
others %>%
group_by_at(itemIdCol) %>%
summarise(Total = sum(simXGrade), Sim.Sum = sum(Similarity)) %>%
mutate(Estimate = Total / Sim.Sum, .keep = "unused") %>%
arrange(desc(.[[itemIdCol]]))
}
calculateSimilarItems <- function(prefs, n = 10) {
items <- unique(prefs[[personIdCol]])
itemSimList <-  apply(
as.data.frame(items),
1,
function(x) topMatches(prefs, x[1],similarity = euclidean, includeOriginal = TRUE)
)
do.call("rbind", itemSimList)
}
topMatches(reviews, 'Toby')
topMatches(reviews, 'Toby',similarity = euclidean)
on_kaggle <- 0
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
# Column that stores the grades
valueIdCol <- "Grade"
# Column that stores calculated similarity value
similarityCol <- "Similarity"
if (on_kaggle == 0){
path <- "./"
} else {
path <- "../input/tmdb-movie-metadata/"
}
topMatches(reviews, 'Toby')
knitr::opts_chunk$set(echo = TRUE)
on_kaggle <- 0
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
# Column that stores the grades
valueIdCol <- "Grade"
# Column that stores calculated similarity value
similarityCol <- "Similarity"
# Path of the directory where data is stored
if (on_kaggle == 0){
path <- "./"
} else {
path <- "../input/tmdb-movie-metadata/"
}
knitr::opts_chunk$set(echo = TRUE)
on_kaggle <- 0
# Column that is used to identify persons
personIdCol <- "Person"
# Column that is used to identify items
itemIdCol <- "Movie"
# Column that stores the grades
valueIdCol <- "Grade"
# Column that stores calculated similarity value
similarityCol <- "Similarity"
# Path of the directory where data is stored
if (on_kaggle == 0){
path <- "./"
} else {
path <- "../input/tmdb-movie-metadata/"
}
library(tidyverse)
reviews <- read_csv(str_c(path, "recommendations.csv"), na="NA")
# Calculate Euclidean Distance Score
euclidean <- function(a,b) 1 / (1 + sqrt(sum((a-b)^2)))
# Calculate Pearson Correlation Score
pearson <- function(a,b) cor(a, b, method = 'pearson')
calculateSimilarityScore <- function(prefs, person1, person2, similarityFunction){
# Extract items that persons have reviewed and make sure items are in the same order
p1Reviews <- prefs[which(prefs[[personIdCol]] == person1),] %>% arrange(.[[itemIdCol]])
p2Reviews <- prefs[which(prefs[[personIdCol]] == person2),] %>% arrange(.[[itemIdCol]])
# Items that both have reviews
sharedItems <- intersect(p1Reviews[,itemIdCol], p2Reviews[,itemIdCol]) %>%
unlist(use.names = FALSE)
if(length(sharedItems) == 0)
return(0)
# Extract the grades of items both have graded
p1Grades <- p1Reviews[which(p1Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
unlist(use.names = FALSE)
p2Grades <- p2Reviews[which(p2Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
unlist(use.names = FALSE)
return(similarityFunction(p1Grades, p2Grades))
}
p1 = 'Lisa Rose'
p2 = 'Gene Seymour'
calculateSimilarityScore(reviews, p1, p2, euclidean)
p1 = 'Lisa Rose'
p2 = 'Gene Seymour'
calculateSimilarityScore(reviews, p1, p2, euclidean)
calculateSimilarityScore(reviews, p1, p2, pearson)
calculateSimilarityScore <- function(prefs, person1, person2, similarityFunction){
# Extract items that persons have reviewed and make sure items are in the same order
p1Reviews <- prefs[which(prefs[[personIdCol]] == person1),] %>% arrange(.[[itemIdCol]])
p2Reviews <- prefs[which(prefs[[personIdCol]] == person2),] %>% arrange(.[[itemIdCol]])
# Items that both have reviews
sharedItems <- intersect(p1Reviews[,itemIdCol], p2Reviews[,itemIdCol]) %>%
unlist(use.names = FALSE)
if(length(sharedItems) == 0)
return(0)
# Extract the grades of items both have graded
p1Grades <- p1Reviews[which(p1Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
unlist(use.names = FALSE)
p2Grades <- p2Reviews[which(p2Reviews[[itemIdCol]] %in% sharedItems), valueIdCol] %>%
unlist(use.names = FALSE)
return(similarityFunction(p1Grades, p2Grades))
}
# calculate similarity scores using the selected similarity function
getSimilarityScores <- function(prefs, person, similarity) {
others <- prefs[which(prefs[[personIdCol]] != person), personIdCol] %>%
distinct()
similarity <- apply(
others[,1],
1,
function(x) calculateSimilarityScore(prefs, person, x, similarity)
)
others[similarityCol] = similarity
others %>%
arrange(desc(.[[similarityCol]]))
}
# Returns the best matches for person from the prefs table
topMatches <- function(prefs, person, n = 5, similarity = pearson, includeOriginal = FALSE) {
others <- getSimilarityScores(prefs, person , similarity)
others %>%
top_n(n, wt = Similarity)
if(includeOriginal == TRUE) {
others <- others %>% mutate(Original = person)
}
others
}
# Returns the best matches for person from the prefs table
topMatches <- function(prefs, person, n = 5, similarity = pearson, includeOriginal = FALSE) {
others <- getSimilarityScores(prefs, person , similarity)
others %>%
top_n(n, wt = Similarity)
if(includeOriginal == TRUE) {
others <- others %>% mutate(Original = person)
}
others
}
topMatches(reviews, 'Toby')
